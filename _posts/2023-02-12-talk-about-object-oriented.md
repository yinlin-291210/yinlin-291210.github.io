---
layout: post
title: "面向对象简述"
subtitle: "Object-oriented brief description"
date: 2023-02-12 22:56:18
author: linbao
header-img:
catalog: true
tags:
  - 编程范式
  - 面向对象
---

## 什么是面向对象

面向对象(Object Oriented)是软件开发方法，是一种编程范式。
面向对象是相对于面向过程来讲的，面向对象的思想，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

大部分编程范式，都是相对而言的，比如函数式和命令式，过程式和对象式。

面向对象编程即 Object Oriented Programming，也就是我们通常意义上说的 OOP。

它的核心点在于建模
面向对象与其说是面向对象，比如说是面向抽象

事物同时存在行为和属性两种特性，而行为和属性又可以统称为属性。
将某种现实事物的各种属性进行抽象，聚合，最终即可总结出该事物的面向对象的抽象模型。

**引申思考，面向过程的本质是什么？**

**面向过程的本质，是对现实事物的描述**

### 类型

而在某些实现了面向对象思想的语言里
该模型 被称之为 类型
如 Java JavaScript C#等等

### 结构体

而在另外一些实现了面向对象的语言里
该模型被称之为 结构体
如 golang c++

#### 注意

**任何实现了面向对象思想的编程语言，都可以同时存在结构体模型和类型模型，到底是取其一还是全都要，取决于语言的设计和实现**

那么面向对象到底在干啥呢？

其实就是通过对事物的建模，将该事物的一切属性和行为都封装在模型内部，从而使得对于该种模型的所有程序操作，都不需要再编写代码。

简而言之，就是复用

因此面向对象最核心的本质，实际上就是**复用**
但复用未必就要面向对象

## 三要素

**封装，继承，多态**

### 封装

什么是封装？
字面的意思就是，将某种东西装入到一个容器里。

从这个字面意思，我们就可以引申出来：**面向对象的建模本身，就是一种封装**。

我们将某一些属性和行为，统一封装进某一个被我们命名的模型里，在使用时，通过将模型的实体构建出来，然后执行我们想要的行为，或者查阅属性，就能很方便的达成目的。

因此我们可以理解到：

封装的目的是为了**简化逻辑**

那么简化有什么好处呢？

1. 越简单的东西，越容易同质化 ---- 由于其特性不多，因此我们很容易就能把不同的封装架构，通过层层封装的形式，最终转换成完全一致的东西，在任一封装的内核，其属性和行为是不同的，但在可视的代码最表层，封装出的行为和属性完全一样，在人类的思维上，这样的使用方式会非常简洁和便于理解。
2. 简单的东西，容易组合 ---- 封装的另外一个作用，就是当复杂的模型实体被封装成简单的模型实体之后，就像是本来不规则的形状，变成了规则的矩形，三角形，正方形，我们很容易就能通过各种中间介质模型的桥接，将各种模型的行为组合在一起，很方便的形成业务方法，完成我们的需求设计落地。
3. 简单的东西，便于理解 ---- 程序除了要满足需求的落地实现之外，还需要符合人类的思维，便于业务知识的传承，复杂的模型在没有对应文档资料的情况下，随着时间推移，最终会湮灭在历史里（参考美国的登月技术），而越是简单的封装，越容易进行高阶抽象，从而让简单的内容，蕴含更多的意义，就譬如象形字和音标字的区别（汉字和英文字符的区别）
4. 封装可以形成协议 ---- 一旦约定了数据，逻辑封装的形式，那么就在实质上形成了协议，很典型的就是我们的 HTTP 协议，其 head，body，foot 实际上就是封装，而其 body 和 head 上的 payload 其实就是我们想要承载的逻辑。

封装除了有以上的意义外，还在面向对象中具备普世的意义，这是什么意思呢？
就是说可能你不经意间就已经使用了封装的方式来完成程序编码，但你自己可能根本就没有意识到，你写的封装一直都存在，并不需要我们刻意去学习，刻意去使用。而了解封装的本质，有助于我们理解比较底层的编码哲学。

**坏处**
封装有没有坏处，当然有：
过深或者过多的封装，会将复杂逻辑封闭在代码深处，非常不利于代码具体业务逻辑的理解和拓展

封装也会导致代码固化，由于上层封装的存在，内部代码很难进行逻辑层面的修改，在实质上形成了代码约束

### 继承

在面向对象里，不提继承，你就会有一种面向对象都白学了的感觉。
但实际上，继承也不过是面向对象的一个特性而已，有没有继承，都不影响你面向对象。

什么是继承？
就是子模型继承了父模型的全部属性，并且还可以创造自己独有的模型属性。子模型作为一个新的模型，可以承担更多更复杂的特性。

从这句话就看得出来，继承只能是全继承（这一点在任何语言都是一样的，但语言和语言之间为了灵活性，又各自添加了各种限制修饰符，比如 public，private 等等，这些与我们的概念无关，都属于语言特性）

其次，继承之外我们还可以添加独有属性。

最后，继承的过程实际上是属性在做增量。

那么继承的目的是什么呢？

继承的目的是为了**管理模型**

继承这一特性的本质，实际上就是增量组合，但没有进行全灵活性的组合，由于父模型的存在，子模型必然拥有共性，并且父模型属性的变化，会引起子模型对应属性的变化。

从这里我们就看得出来，在无限多子模型的情况下，我们可以通过修改父模型的某个属性，来引发全部子模型的该属性的变化。

这是一对多的映射，即用 1 来管理 N。

继承的结构，在单父模型继承的情况下，属于树型层级结构。
在多父模型继承的情况下，属于网状层级结构。

1. 通过继承，我们可以形成非常直观和良好的模型关系，方便于我们对模型的属性进行管理
2. 区分，通过继承，子模型共同的属性（父模型特性）和独有的属性（增量的特性）被区分了开来，可以分别进行管理。
3. 继承的实例化机制，以层级构造的模式，创造出继承了全部属性的模型实体，方便我们执行具体的代码工作。(抽象的模型也可以进行工作，但其灵活度不够高，切换其执行逻辑的主体会比较麻烦，而实体自身就是执行主体)。因此实例化的本质，其实就是继承，只不过继承生成的是新的模型，而实例化生成的是模型的实体，但其实模型的实体也是模型。
4. 追溯，由于继承的存在，模型的任何一个属性的来源，在代码层面都可以很方便的进行追溯，从而很容易的进行代码的维护，拓展。

继承有非常多的意义，我们不进行一一赘述，下面来说说继承的坏处：

继承最大的坏处**特性粒度**

我们来搞两个模型

模型名：哺乳动物
特性：子代哺乳，胎生，脊椎动物，肺呼吸

模型名：鱼
特性：子代卵生或卵胎生，鳃呼吸，脊椎动物，有鳍，水生

进行多重继承，我们希望创建一个新的模型

模型名：鲸
特性：（来自哺乳动物模型）子代哺乳，胎生，脊椎动物，肺呼吸，（来自鱼模型）子代卵生或卵胎生，鳃呼吸，脊椎动物，有鳍，水生

很明显嘛，在没有添加鲸模型的特性的情况下，有些特性压根就是错的：
子代卵生或卵胎生，鳃呼吸

那么怎么解决这个问题，很容易能看出来必须把呼吸类型不同的动物单独踢出去建模型，区分出肺呼吸模型和鳃呼吸模型，而子代的生育类型也得单独踢出去，建立卵生或卵胎生模型和哺乳模型

此时因为鲸独特的现实特性，导致我们用哺乳动物模型和鱼模型来进行继承，完全不行，必须倒逼父模型进行新增或者修改。

那么我们能不能通过鲸模型的特性来覆盖两个父模型的特性呢？
能当然是能，但是不能彻底解决哺乳动物和鱼不能一起继承的问题。
从人类思维的范畴，哺乳动物和鱼一般来说是两回事，不会被一起思考，但对于程序来说，模型就是模型，这俩模型可以通用。

模型的粒度太大，导致继承出错，或者模型的粒度太小，导致模型太多。
这充分显示了面向对象的劣势：无法真正对现实抽象，因为信息量是在太大了。

表现在代码层面就是，越是复杂的系统（模型复杂，模型多），P 用没有的代码就越多，简单说就是冗余越多。大部分都是为了 fix 类似这种类型之间的冲突问题。

继承第二个大坏处**增量特性**

继承只能做增量，无法做减量，我相信只要是写过继承的同学，应该隐隐约约都意识到这个问题了。

简单说就是，子模型最多只能覆盖父模型的某个特性，而不能删除它。
当继承层级越来越多，增量特性越来越多，没用的特性也越来越多，占用资源越来越多，代码量越来越大，总之就是一句话，一切都在增加。

那么为什么只能做增量呢？

因为继承是自上而下的，他是有顺序的。

必然是子继承父，这就导致子模型对于父模型不能进行管理，简单来说就是，海豚模型下的子模型鲸和江豚。
你不能通过江豚去修改海豚模型，这会导致鲸模型也发生改变，你也不能通过鲸模型去修改父模型海豚的模型，这会导致江豚模型发生改变。

看到了吗？父向子的管理是可行的，但是反过来就不行了。

于是增量特性就发生了。

越是向下的子模型，其增量特性就越多，没有的特性就越多。

**继承的粒度和增量问题，是摧毁继承的最后两根稻草**
**现代语言已经越来越少的去设计继承机制了**

**面向对象正在以一些全新的理念，来完善自己的方法论**
**而继承的根本目的，依然是为了复用**

### 多态

在三大特性里，多态是最简单的。

多态的本质，实际上是接口实现，是为了多种不同的数据类型以及不同数量的数据，提供一个统一的数据出入口。

那么多态有什么实际意义呢？

a + b = c

转换成函数就是

```js
function (a, b){
  var c = a + b;
  return c;
}
```

如果我不满足于两个参数，希望存在第三个加数，那么就变成了
a + b + d = c

```js
function (a, b, d = 0){
  var c = a + b + d;
  return c;
}
```

一摸一样的计算方式，同一个计算结果，只是计算的加数的数量不同，如果我把这样的函数不做处理，就这么写在这里，那么最后就是一大堆类似而又不相信的代码，非常的多余。

```js

fucntion(){
  var c = 0;
  var arr = Array.slice(arugments, 0);
  var i = 0, len = arr.length;
  for( ; i< len; i++){
    c += arr[i];
  }
  return c;
}
```

上面这个函数，代码可能有误，但按其思路实现，不管加数的参数有多少，我们都可以计算出最终的 c 值，并且返回，这就是一个典型的多态。

那么我们不难理解到

多态的本质，实际上就是**动态化**

多态有什么好处呢？

**省代码**

多态有什么坏处呢？

**极端的多态根本无法纯靠代码理解，而为了配合多态，你很可能需要建立很多难以想象的参数模型**

比如**多态模型/多态类型**

## 继承的种类

### 经典继承

经典继承就不用多说了，通过构造器自上而下构造的方式，来完成模型实体的生产；通过由子向父覆盖的方式，来完成模型特性的继承和创建

经典继承是一种非常方便理解，也非常方便使用的继承方式。

其最大的特色就是**规范化**，一切属性皆有迹可循

经典继承常常出现在静态语言的实现当中

### 原型继承

原型继承，实际上是从设计模式中的享元模式衍生而来。

共享一个原型对象，通过操作原型对象的引用，来完成继承和构造的过程。

这是一种非常灵活的继承方式，继承中的一切过程都可以被程序开发者控制。

优点是轻量化，灵活性。
缺点是难以控制，难以理解

### 组合继承

组合式继承，利用方法的组合，来完成继承类似的模型实体的构建。

函数即模型，解决了继承机制不能做减量的问题。

需要什么组合什么。

优点是完全定制化模型，具备一定的灵活性。
缺点是逻辑极端复杂，难以理解和实现。

## 总结

面向对象的本质，实际上就是对当前工作模型的抽象，我们将自己写好的许多变量，函数聚合在一起，挂载在我们命名的一个模型对象上，然后之后我们在进行工作时，就不需要再去寻找对应的行为了，我们只要取得该模型的实体，然后从实体直接进行行为的调用或者属性的查阅就可以了。

方便！
