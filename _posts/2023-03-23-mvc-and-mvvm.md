---
layout: post
title: "从代码实践的角度思考mvc及mvvm的设计思想"
subtitle: "MVC MVVM"
date: 2023-03-23 20:25:05
author: linbao
header-img:
catalog: true
tags:
  - 编程范式
---

## MVC 设计思想

MVC 是 model、view、controller 的简称。它是一种软件的设计思想，将应用的一个输入、处理、输出按照模型层，视图层，控制层进行分层设计。

1、模型: 业务逻辑包含了业务数据的加工与处理以及相应的基础服务(为了保证业务逻辑能够正常进行的事务、安全、权限、日志等等的功能模块)
2、视图:展现模型处理的结果；另外，还要提供相应的操作界面，方便用户使用。
3、控制器:视图发请求给控制器，由控制器来选择相应的模型来处理；模型返回的结果给控制器，由控制器选择合适的视图。

在 mvc 的设计思想里，M model 数据模型，V View 视图，字面的意思就是用户可以看到的部分，用来展示的 UI 等，C Controller 控制器，用来在视图和模型之间做数据交互的控制层。
MVC 并不是环状结构，而是以 C 层为中心的中心化结构。

mvc 的设计并不局限于前端后端，在整体架构上，都可以使用 mvc 结构，比如大前端对于前后端整体结构来讲，即是 V，而后端从接口向下，DB 向上，基本都可以算作是控制器层，而对应的 DB 以及 DB 之上的封装 entity 实体层，都可以算作是 M 层。

那么有一个问题就暴露出来了，MVC 结构里，业务到底在哪？
其实这是 MVC 结构的是一个缺憾，MVC 结构强调的是对数据行为的控制，导致他没有对业务进行明确的划分，因此在实际使用当中，经常会有人再次封装 service，facede 层，来做数据层与控制器之间的业务封装层，确定复杂的业务。

在代码结构上，我们会看到类似如下的结构

--api
--facede
--controller
--entity
--db

分层并没有明确的说法，到底谁要在谁的上边，谁在谁的下边，归根结构，mvc 结构只是为了从数据行为的角度，对代码进行划分，方便管理和维护。
优缺点

1. 低耦合性，前后端分离，更有效率。视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动 MVC 的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。
1. 高重用性和可适用性，MVC 模式允许你使用各种不同样式的视图来访问同一个服务器端的代码。它包括任何 WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。例如，很多数据可能用 HTML 来表示，但是也有可能用 WAP 来表示，而这些表示所需要的命令是改变视图层的实现方式，而控制层和模型层无需做任何改变。
1. 较低的生命周期成本，MVC 使开发和维护用户接口的技术含量降低。
1. 快速的部署，使用 MVC 模式使开发时间得到相当大的缩减，它使程序员（Java 开发人员）集中精力于业务逻辑，界面程序员（HTML 和 JSP 开发人员）集中精力于表现形式上。
1. 可维护性，分离视图层和业务逻辑层也使得 WEB 应用更易于维护和修改。
1. 有利于软件工程化管理，由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。

## MVVM 设计思想

mvvm 设计思想，并不是 m,v,v,m 设计思想，而是 m,v,vm 设计思想。
他跟 mvc 最大的区别就是将控制器 c 层所作的很大一部分事情，放在 vm 层。
mvvm 设计思想与 mvc 设计思想在逻辑上完全一致，两者最大的区别，就在于 vm 与 C 的侧重点不同。

c 侧重业务，而 vm 则侧重于视图 v 的交互。
这两种体系在代码上的最大直观感受就是，mvc 思想的 j2ee 体系，服务端渲染的 jsp 和 controller 会在开发过程中无限膨胀，而这两个组合起来是典型的 c.
而对应的 mvvm 设计思想，假如依然是 j2ee 体系的话，那就只有 jsp 在膨胀。
我们会发现我们在使用 mvvm 前端框架时，某些特定的文件会不断扩张自己的体积，最终甚至会达到千行这种非常不寻常的代码量级。

mvvm 当中：
m 即是 model, 它决定了前端 vo 的数据模型，数据行为，转换，生成，分发等逻辑的集合。
v 即是视图，它决定了 UI 交互，主题，用户事件响应接口等。
vm 即是视图模型，它决定了 v 所使用的数据模型以及数据模型实体所对应的一系列业务逻辑。

mvvm 并不是一种先进的思想，准确来说 mvc,mvvm,mvp 等代码结构设计思想，都不能算得上是先进，他们各有优缺点，也有对应的使用场景。
我们主要介绍 mvvm 设计思想。
m 和 v 是非常好辨认的，我们前端从接口获取数据，取得一个 json 字符串，经过解析之后，可以拿到内中的数据，这个数据，其实就是后端 service 层（控制器内的业务层）给我提供的一个 vo,也就是一个我们所需要的数据模型的实体。
而数据模型的实体，实际上也就是数据模型自身属性的一部分表现。
此外，数据字段的类型，数据结构，数据字段对应的校验行为，数据的 getter，setter，以及数据的装饰器，转换器，封装等，统统属于模型层。
举个非常形象的例子，在 vue 全家桶当中，vuex 框架的所有 api，都是 m 层的东西，凡是可以深刻理解这些 api 的，自然也会对 m 层有一个深刻的认知。
其中 state 对应数据模型，state 里缓存的数据，则对应数据模型实体，mutation 对应 setter, getter 就是通常意义的 getter，action 则是典型的数据逻辑装饰器, dispatch 则是分发器。
实际上 vuex 没有暴露数据验证的接口，但 m 里，其实是需要这个的。

再说 v，view 作为视图，它的作用相对单纯，对于前端来说，v 最大的作用就是提供交互入口，体现在代码层面就是浏览器的事件模型 event 对象。
使用 mvvm 框架，event 会被封装起来，但我们从代码层面还是可以看到，譬如@click，@change 等事件指令。
视图再一个作用，就是提供交互和呈现，这个就没啥说的了。
另外它还涵盖了一个东西，即是视图上的数据字典，譬如我们静态的国际化信息，某些静态的数据等等。

最后再重点说一下 vm.
在 mvvm 设计思想里，vm 是最容易被人误解的，也是最费解的。
vm 全名是 viewModel，视图模型。
其实这个 viewModel 涵盖了两个概念。
第一，视图上的业务逻辑，体现在我们的代码上，就是我们在 vue 模板当中编写的大量指令，表达式，以及在模板当中所使用的方法，函数，过滤器等等。
第二，视图上的数据模型。
这一条是最费解的，什么叫视图上的数据模型。视图模型与数据模型是完全不同的两个概念。
我们在学习 java 时，会了解到四大对象，vo,do,dto,po，vo，视图对象，do,领域对象，可以理解为模块对象，dto,数据传输对象，也可以理解为数据传输转换对象，po，持久化对象，实际上就是数据库表结构映射。
在这四个对象里，我们接触最多的就是 vo 和 dto，一般来说，大型项目都会将 po 转换成 dto 传输出来，提供给应用使用，而小型项目则可能会把 po 直接暴露出来。
但对于应用端来说，我们用于展示的数据，其实叫作 vo。

我们可以回想一下，我们经常在组件代码里做的一件事，就是把某个数据的里数据做一下过滤或者转换，然后再展示到视图上，这个过程，其实就是把从数据模型实体里拿到的 dto，转换成了最终展现的 vo。
所谓的 vm 实际上就是 vo 的模型。

在另外一个层面，我们在应用端做表单展示时，也会经常干一件事，就是把 dto 数据重新填写到表单上，然后进行编辑操作，可是这里就有个问题了，对于编辑操作，任何一个数据改变，都会直接改变数据源对象，即我们字面意思上的双向绑定，但对于 dto 来说，在没有进行保存业务之前，他都是不变的。
矛盾产生了。
我们不能对没有保存过的 dto 对象进行编辑，因为这种编辑操作，基于表单的双向绑定机制，会导致 dto 的改变。
之所以会出现这个问题，就是因为对 vm 认识不深刻。
vm 并不是用来提供数据的，而是用来承载数据的，他是视图上数据集合的载荷（payload）。
我们比较正确的区分 m 和 vm 的办法，应该是在 m 的 getter 当中，对数据进行复制，将复制的数据作为 vo，传递给 vm,然后由 vm 操作。
不管 vm 如果处理数据，我们原本的 dto 数据模型，都不会因此发生改变，直到你点击保存按钮，并且成功调用了业务侧提供的保存业务。

我们可以发现，在这个层面上，我们整体业务逻辑其实少了一层，即是 mvc 的 c。因为 vm 不会去保存数据，m 也不会，v 就更不会。
那我们要怎么去执行业务，保存数据呢？
我们只能新建一个 business 层。

所以 代码就会变成这样 m------data------> vm ---------event--------> business ------http/ws ---------> m
没有 v 啥事了，其实不是没有 v 啥事，而是在这个数据流动的过程里，v 是不起任何作用的，它所有的变化，都是数据驱动，m 变化，导致 vm 变化，vm 变化，导致 v 变化。
但是在实际对数据的操纵，以及业务的调用当中，v 不起任何作用。

我们看个简单的例子

```javascript
onLoginClick:function(user){
    if(UserModel.validator(user)){
        await AccountBusiness.login(user);
    }
}
```

这一共三行代码，就是一个典型前端 mvc 结构，我们刚才还在讲的是 mvvm，怎么忽然变成 mvc 了？
其实 mvc 跟 mvvm 没有本质区别，两者的区别前边也已经说了，就是侧重不同，c 更侧重业务，vm 怎么更侧重视图。
第一行代码 onLoginClick 是作为一个 DOM 元素的点击事件的事件响应函数，简单来说，就是事件交互的接口。
第二行代码 UserModel.validator(user)，实际上就是 m 的数据行为，对自身的实体数据进行验证。
第三行代码 AccountBusiness.login(user)，实际上就是业务侧的调用，也就是在做业务，这其实就是一个 controller.
那 vm 跑哪去了？
vm 就是被那个传来传去的参数 user。
user 是我们从登录的表单上收集的数据，包含 account 信息和 password 信息。
这两个信息共同组成了一个 vm,也就是登录页面组件内 data 的一部分。假如我们记住了账号和密码，那么这个 vm 就将在页面被初始化时被填写，如果我们没有记住，那么 vm 就是空的。
但不管填或者不填，这个 vm 他的数据结构，都将由真实的数据模型 m 决定。

换句话说，我们在表单上使用的 vm 和真实数据之间，并不是一致的，他们有继承关系，除此之外，大概率没有任何关系。
从代码结构的设计来讲，我们在使用 vue 的组件时，基本上所有的代码都会跟上边的 3 行代码类似，也就说，我们组件内，除了样式，部分视图模型的表达式，事件响应函数之外，几乎没有实体业务逻辑。

## MVC 和 MVVM 到底是什么？

mvc 和 mvvm 究其本质，既不是设计模式，也不是什么架构体系，他们归根结底，实际上是代码结构的设计思想。
他们出现的本质，就是为了方便的管理代码。
使得我们的代码便于维护，易于上手，理解起来没有壁垒。
对于前端来说 mvvm 在单一组件模式下，优点是全面，快速，做迭代开发可以高效的完成任务，但是缺点和优点一样明显：
单一组件的 mvvm 设计，会导致代码无限的增长，尤其是在我们当前项目根本没有使用 m 来管理数据和状态的情况下。
那么从 mvvm 转换成 mvc 又会有什么优点和缺点呢？
优点其实在上边已经说了，mvvm 转换成 mvc 依然是纯正的 mvc，mvc 的优点他都有，甚至由于前端大部分情况下不依赖业务，因此作为前端 mvc 比 service 侧要纯正的多。
但缺点呢，缺点就是要多维护很多文件或者代码，在某种程度上，会增加项目的理解难度，增加思维的负担。
