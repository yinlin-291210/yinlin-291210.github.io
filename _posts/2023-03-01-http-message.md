---
layout: post
title: "重拾HTTP之报文"
subtitle: "HTTP Message"
date: 2023-03-01 11:25:28
author: linbao
header-img:
catalog: true
tags:
  - http
---

首先，引入一个老生常谈的问题，当我们在网页浏览器的地址栏中输入`URL`时，`Web`页面是如何呈现的？
粗略的总结如下：

```
1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）

5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）

6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）

7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）

8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
```

## HTTP 协议访问 Web

`Web`页面不能凭空显示出来。根据 `Web` 浏览器地址栏中指定的 `URL`，`Web` 浏览器从 `Web` 服务器端获取文件资源`（resource）`等信息，从而显示出 `Web` 页面。 像这种通过发送请求获取服务器资源的 `Web` 浏览器等，都可称为客户端`（client）`。

`Web`使用一种名为`HTTP（HyperText Transfer Protocol，超文本传输协议）`的协议作为`规范`，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，`Web`是建立在`HTTP`协议上通信的。

## HTTP 报文内的 HTTP 信息

HTTP 协议描述的是发送方与接收方的通信协议，通过两方的自觉遵守而存在，当然有不少的浏览器并没有百分百遵守这份协议。HTTP 是运行于应用层的协议，基于 TCP 协议而运作。
基本上是客户/服务器对答模式，其中也包括在传输过程中的代理，网关，通道，缓存等都需要遵守这份协议。下面以 HTTP 1.1 版本为主，来了解报文内容。

### 1.1 HTTP 报文

首先 HTTP 报文会像河水一样流动，不管是请求报文还是响应报文，所有报文都会向下游流动。

用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。 HTTP 报文本身是由多行（用 CR + LF 作换行符）数据构成的字符串文本。
HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的 空行（CR+LF）来划分。通常，并不一定要有报文主体。
![](/img/in-post/http-message/20211223-094159-369.png)

### 1.2 请求报文及响应报文的结构

我们来看一下请求报文和响应报文的结构。
![](/img/in-post/http-message/20211223-094252-929.png)
![](/img/in-post/http-message/20211223-094339-701.png)

请求报文和响应报文的首部内容由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。

**请求行(起始行)**
包含用于请求的方法，请求 URI 和 HTTP 版本。

**状态行**
包含表明响应结果的状态码，原因短语和 HTTP 版本。

**首部字段**
包含表示请求和响应的各种条件和属性的各类首部。
一般有 4 种首部，分别是：`通用首部`、`请求首部`、`响应首部`和`实体首部`。

**其他**
可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。
注：RFC（征求意见稿）是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及 UNIX 和互联网社群的软件文件，以编号排定。RFC 文件是由互联网协会（ISOC）赞助发行。
一个 RFC 文件在成为官方标准前一般至少要经历 4 个阶段：因特网草案、建议标准、草案标准、因特网标准。

![](/img/in-post/http-message/v2-626730a88ec4c6a66738d6fba41a09b1_r.jpg)

#### 1.2.1 报文语法

所有的 HTTP 报文都可以分为两类：请求和响应报文
![](/img/in-post/http-message/clipboard-202112231417-po2k5.png)
![](/img/in-post/http-message/clipboard-202112231418-4waq4.png)
(1) 请求报文格式

```
<method> <request-URL> <version>
<headers>

<entity-body>
```

(2) 响应报文格式

```
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。
紧挨着的 200 OK 表示请求的处理结果的状态码（status code）和原因 短语（reason-phrase）。
下一行显示了创建响应的日期时间，是首部 字段（header field）内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体（entity body）。
响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代 码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

#### 1.2.2 HTTP 方法

请求方法是大小写敏感的，方法名区分大小写，注意要用大写字母。通常我们在开发过程中，并没有注意大小写，主要是工具帮我们做了转换。

**GET ：**获取资源
GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。
也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。
![](/img/in-post/http-message/clipboard-202112231429-modfl.png)
![](/img/in-post/http-message/clipboard-202112231434-apxu4.png)

**POST：**传输实体主体
POST 方法用来传输实体的主体。虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。
虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。
![](/img/in-post/http-message/clipboard-202112231435-vhk0e.png)

**PUT：**传输文件
PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。
但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件, 存在安全性问题，因此一般的 Web 网站不使用该方法。
若配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。
![](/img/in-post/http-message/clipboard-202112231437-gdrom.png)

**HEAD：**获得报文首部
HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。
![](/img/in-post/http-message/clipboard-202112231438-zntw1.png)
![](/img/in-post/http-message/clipboard-202112231438-5t9le.png)

**DELETE：**删除文件
DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。
但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。
![](/img/in-post/http-message/clipboard-202112231441-yi3qy.png)

**OPTIONS：**询问支持的方法
OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。
![](/img/in-post/http-message/clipboard-202112231442-mwlnx.png)
![](/img/in-post/http-message/clipboard-202112231442-vpdmr.png)

**TRACE：**追踪路径
TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。
客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。
但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。
![](/img/in-post/http-message/clipboard-202112231444-ydh0y.png)

**CONNECT：**要求用隧道协议连接代理
CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
![](/img/in-post/http-message/clipboard-202112231445-r3n9a.png)

#### 1.2.3 安全方法

HTTP 定义了一组被称为安全方法的方法，这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。
客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。
因此 RFC 定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。
但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如使用 GET 修改用户信息的情况。
引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。

#### 1.2.4 语法/语义

语法：方法名 URI 协议/版本 语法就是规范，是规范就需要大家去遵循。
语义：GET 的语义就是「获取资源」, POST 的语义是「处理资源」。

当然在符合语法的前提下实现违背语义的行为也是可以做到的，比如使用 GET 方法修改用户信息，POST 获取资源列表，这样就只能说这个请求是「合法」的，但不是「符合语义」的。
比如我们在调 GET 请求时，除了传 params，还可以携带 body，同理 POST 请求除了传 body，也可以携带 params。显然这并不是我们正确使用 HTTP 方法的初衷，随着前后端分离，specification(规范)和 implementation(实现)
的差异也越来越大，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致 RESTful API 构架的流行。

HTTP 协议本身是一种面向资源的应用层协议，但对 HTTP 协议的使用实际上存在着两种不同的方式：一种是 RESTful 的，它把 HTTP 当成应用层协议，比较忠实地遵守了 HTTP 协议的各种规定；
另一种是 SOA 的，它并没有完全把 HTTP 当成应用层协议，而是把 HTTP 协议作为了传输层协议，然后在 HTTP 之上建立了自己的应用层协议。

#### 1.2.5 GET/POST 区别

1.根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。
(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，
就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
(2).幂等的意味着对同一 URL 的多个请求应该返回同样的结果。

```
　幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。
　幂等有一下几种定义：
　对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。
　对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。
```

但在实际应用中，以上 2 条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。
从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。

2.根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过 POST 实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。

剩下的我们再从表象上看看差异：

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。
  (火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### 1.2.6 GET 传参最大长度的理解误区

1、HTTP 协议 未规定 GET 和 POST 的长度限制
2、GET 的最大长度限制是因为 浏览器和 web 服务器限制了 URI 的长度，并不是单指参数的长度。
3、不同的浏览器和 WEB 服务器，限制的最大长度不一样，若只支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte。

### 1.2.7 如何理解 URI？

URI, 全称为(Uniform Resource Identifier), 也就是`统一资源标识符`，它的作用很简单，就是区分互联网上不同的资源。
但是，它并不是我们常说的网址, 网址指的是`URL`, 实际上`URI`包含了`URN`和`URL`两个部分，由于 `URL` 过于普及，就默认将 `URI` 视为 `URL` 了。
URI 的结构
URI 真正最完整的结构是这样的。
![](/img/in-post/http-message/clipboard-202112241119-uxy7h.png)
可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。

**scheme** 表示协议名，比如 http, https, file 等等。后面必须和://连在一起。
**user:passwd@** 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。
**host:port**表示主机名和端口。
**path**表示请求路径，标记资源所在位置。
**query**表示查询参数，为 key=val 这种形式，多个键值对之间用&隔开。
**fragment**表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。

举个例子:

```
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
```

这个 URI 中，https 即 scheme 部分，www.baidu.com为host:port部分（注意，http 和 https 的默认端口分别为 80、443），/s 为 path 部分，而 wd=HTTP&rsv_spt=1 就是 query 部分。
URI 编码
URI 只能使用 ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。

### 1.2.7 状态码

状态码(status code)部分解析：

作用：对结果进行类型化描述，例如获取成功，内容未找到。
1xx（临时性消息系列状态码）

```
100 （继续）请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
场景：客户端向服务端传递大文件分段传输，传完一段服务器不用急着给我们响应，因为后面还有东西要传。
做法：在请求头中添加一个额外的header表示后续还有东西要上传，最终最后一个上传时不添加这个额外的Header表示后面没有东西要上传啦，服务器假如全部接收成功，最终返回200状态码。

101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。
```

2xx（成功系列状态码）

```
200:OK 请求成功。一般用于GET与POST请求

201:Created 已创建。成功请求并创建了新的资源

202:Accepted 已接受。已经接受请求，但未处理完成

203:Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本

204:No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档

205:Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域

206:Partial Content 部分内容。服务器成功处理了部分GET请求
```

3xx（重定向系列状态码）

```
300:Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择

301:Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替

302:Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

303:See Other 查看其它地址。与301类似。使用GET和POST请求查看

304:Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

305:Use Proxy 使用代理。所请求的资源必须通过代理访问

306:Unused 已经被废弃的HTTP状态码

307: Temporary Redirect 临时重定向。与302类似。使用GET请求重定向

```

4xx（客户端错误系列状态码）

```
400:Bad Request 客户端请求的语法错误，服务器无法理解

401:Unauthorized 请求要求用户的身份认证

402:Payment Required 保留，将来使用

403:Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求

404:Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面

405:Method Not Allowed 客户端请求中的方法被禁止

406:Not Acceptable 服务器无法根据客户端请求的内容特性完成请求

407:Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权

408:Request Time-out 服务器等待客户端发送的请求时间过长，超时

409:Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突

410:Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置

411: Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息

412: Precondition Failed 客户端请求信息的先决条件错误

413: Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息

414: Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理

415: Unsupported Media Type 服务器无法处理请求附带的媒体格式

416: Requested range not satisfiable 客户端请求的范围无效

417: Expectation Failed 服务器无法满足Expect的请求头信息

```

5xx（服务端错误系列状态码）

```
500: Internal Server Error 服务器内部错误，无法完成请求

501: Not Implemented 服务器不支持请求的功能，无法完成请求

502: Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

503: Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

504: Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求

505: HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理
```

### 1.3 编码提升传输速率

HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。
通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。

#### 1.3.1 报文主体和实体主体的差异

**报文（message）**
是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。

**实体（entity）**
作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。

HTTP 报文的主体用于传输请求或响应的实体主体。
通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。
报文和实体这两个术语在之后会经常出现，请事先理解两者的差异。

#### 1.3.2 压缩传输的内容编码

向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP 压缩文件之后再添加附件发送。
HTTP 协议中有一种被称为内容编码 的功能也能进行类似的操作。
内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。
![](/img/in-post/http-message/20211223-104029-631.png)

常用的内容编码有以下几种。

**gzip**（**GNU zip**）

**compress**（**UNIX** 系统的标准压缩）

**deflate**（**zlib**）

**identity**（不进行编码）

#### 1.3.3 分割发送的分块传输编码

在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。
这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）。
![](/img/in-post/http-message/clipboard-202112231043-r2o4p.png)

分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。
使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。 HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。

#### 1.3.4 发送多种数据的多部分对象集合

![](/img/in-post/http-message/20211223-104522-559.png)
发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮 件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。
例如，图片等二进制数据以 ASCII 码字符串编码的方式指明， 就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。
相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。
多部分对象集合包含的对象如下。

**multipart/form-data**
在 Web 表单文件上传时使用。

**multipart/byteranges**
状态码 206（Partial Content，部分内容）响应报文包含了多个范 围的内容时使用。

**multipart/form-data**

```
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="field1"

Joe Blow
--AaB03x
Content-Disposition: form-data; name="pics"; filename="file1.txt"
Content-Type: text/plain

...（file1.txt的数据）...

--AaB03x--
```

**multipart/byteranges**

```
HTTP/1.1 206 Partial Content
Date: Fri, 13 Jul 2012 02:45:26 GMT
Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/800054

...（范围指定的数据）...

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...（范围指定的数据）...

--THIS_STRING_SEPARATES--
```

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。有关这个首部字段，我们稍后讲解。
使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“--”标记
（例如：- -AaB03x、--THIS_STRING_SEPARATES），而在多部分对象集合对 应的字符串的最后插入“--”标记（例如：--AaB03x--、-- THIS_STRING_SEPARATES--）作为结束。
多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。

#### 1.3.5 获取部分内容的范围请求

以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。
为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。 要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求（Range Request）。
对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。

![](/img/in-post/http-message/20211223-105925-929.png)

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。
byte 范围的指定形式如下。

**5001~10 000** 字节

```
Range: bytes=5001-10000
```

从 **5001** 字节之后全部的

```
Range: bytes=5001-
```

从一开始到 **3000** 字节和 **5000~7000** 字节的多重范围

```
Range: bytes=-3000, 5000-7000
```

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。
如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的 实体内容。
